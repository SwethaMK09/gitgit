its a kotlin android studio app that opens dual camera and if i click on front camera it will open a stretched view of front camera. and if i click on it it will open the dual camera. i dont want it for full screen it looks too stretched can you modify my code so that it does not stretch

MainActivity:
package com.example.multicam
 
import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.SurfaceTexture
import android.hardware.camera2.CameraAccessException
import android.hardware.camera2.CameraCaptureSession
import android.hardware.camera2.CameraCharacteristics
import android.hardware.camera2.CameraDevice
import android.hardware.camera2.CameraManager
import android.os.Bundle
import android.util.Log
import android.util.Size
import android.view.MotionEvent
import android.view.Surface
import android.view.TextureView
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import java.util.*
import kotlin.math.abs
 
class MainActivity : AppCompatActivity() {
 
    private lateinit var cameraManager: CameraManager
    private lateinit var textureViewFront: TextureView
    private lateinit var textureViewBack: TextureView
 
    private val cameraPermissionCode = 123
//    private var frontCameraTapCount = 0
//    private var backCameraTapCount = 0
    private var frontCameraFullScreen = false
    private var backCameraFullScreen = false
 
    @SuppressLint("MissingInflatedId", "ClickableViewAccessibility")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
 
        cameraManager = getSystemService(Context.CAMERA_SERVICE) as CameraManager
        textureViewFront = findViewById(R.id.textureViewFront)
        textureViewBack = findViewById(R.id.textureViewBack)
 
        checkCameraPermissions()
 
        try {
            val cameraIdList = cameraManager.cameraIdList
            val rearCameraId = cameraIdList.firstOrNull { id ->
                cameraManager.getCameraCharacteristics(id)
                    .get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK
            }
            val frontCameraId = cameraIdList.firstOrNull { id ->
                cameraManager.getCameraCharacteristics(id)
                    .get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT
            }
 
            if (rearCameraId != null && frontCameraId != null) {
                openCamera(frontCameraId, textureViewFront)
                openCamera(rearCameraId, textureViewBack)
            } else {
                Log.e("CameraError", "Front or Rear camera not found.")
            }
        } catch (e: CameraAccessException) {
            Log.e("CameraError", "Error accessing camera: ${e.message}")
        }
 
        textureViewFront.setOnTouchListener { _, event ->
            handleCameraViewClick(event, textureViewFront)
            true
        }
 
        textureViewBack.setOnTouchListener { _, event ->
            handleCameraViewClick(event, textureViewBack)
            true
        }
 
//        textureViewFront.setOnTouchListener { _, event ->
//            if (event.action == MotionEvent.ACTION_DOWN) {
//                if (frontCameraTapCount == 1) {
//                    // Double-tap detected, switch between full-screen and dual-camera views
//                    toggleFullScreenMode(textureViewFront)
//                    frontCameraTapCount = 0
//                } else {
//                    // First tap, increment tap count
//                    frontCameraTapCount++
//                }
//            }
//            true
//        }
//
//        textureViewBack.setOnTouchListener { _, event ->
//            if (event.action == MotionEvent.ACTION_DOWN) {
//                if (backCameraTapCount == 1) {
//                    // Double-tap detected, switch between full-screen and dual-camera views
//                    toggleFullScreenMode(textureViewBack)
//                    backCameraTapCount = 0
//                } else {
//                    // First tap, increment tap count
//                    backCameraTapCount++
//                }
//            }
//            true
//        }
    }
 
    private fun openCamera(cameraId: String, textureView: TextureView) {
        if (ContextCompat.checkSelfPermission(
                this,
                Manifest.permission.CAMERA
            ) == PackageManager.PERMISSION_GRANTED
        ) {
            try {
                cameraManager.openCamera(cameraId, object : CameraDevice.StateCallback() {
                    override fun onOpened(camera: CameraDevice) {
                        configureCamera(camera, textureView)
                    }
 
                    override fun onDisconnected(camera: CameraDevice) {
                        camera.close()
                    }
 
                    override fun onError(camera: CameraDevice, error: Int) {
                        camera.close()
                        Log.e("CameraError", "Error opening camera: $error")
                    }
                }, null)
            } catch (e: CameraAccessException) {
                Log.e("CameraError", "Error opening camera: ${e.message}")
            }
        }
    }
 
    private fun configureCamera(camera: CameraDevice, textureView: TextureView) {
        val surfaceTexture = textureView.surfaceTexture
        val previewSize = chooseOptimalSize(camera.id, textureView.width, textureView.height)
 
        surfaceTexture?.setDefaultBufferSize(previewSize.width, previewSize.height)
        val surface = Surface(surfaceTexture)
 
        val captureRequestBuilder =
            camera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW).apply {
                addTarget(surface)
            }
 
        camera.createCaptureSession(listOf(surface), object : CameraCaptureSession.StateCallback() {
            override fun onConfigured(session: CameraCaptureSession) {
                session.setRepeatingRequest(captureRequestBuilder.build(), null, null)
            }
 
            override fun onConfigureFailed(session: CameraCaptureSession) {
                Log.e("CameraError", "Failed to configure camera session.")
            }
        }, null)
    }
 
    private fun toggleFullScreenMode(textureView: TextureView) {
        val layoutParams = textureView.layoutParams
        if (layoutParams.height == 0) {
            // Switch to full-screen mode
            layoutParams.height = ViewGroup.LayoutParams.MATCH_PARENT
            textureView.layoutParams = layoutParams
        } else {
            // Switch to dual-camera view
            layoutParams.height = 0
            textureView.layoutParams = layoutParams
        }
    }
 
    private fun chooseOptimalSize(cameraId: String, width: Int, height: Int): Size {
        try {
            val characteristics = cameraManager.getCameraCharacteristics(cameraId)
            val streamConfigurationMap =
                characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    ?: throw RuntimeException("Cannot get available preview sizes")
 
            val sizes = streamConfigurationMap.getOutputSizes(SurfaceTexture::class.java)
 
            // Choose an optimal size based on your requirements.
            // For simplicity, you can choose the size with the closest aspect ratio to the given width and height.
            val targetRatio = width.toDouble() / height
            var optimalSize: Size? = null
            var minDiff = Double.MAX_VALUE
 
            for (size in sizes) {
                val ratio = size.width.toDouble() / size.height
                val diff = abs(ratio - targetRatio)
                if (diff < minDiff) {
                    optimalSize = size
                    minDiff = diff
                }
            }
 
            return optimalSize ?: throw RuntimeException("Cannot find a suitable preview size")
        } catch (e: CameraAccessException) {
            throw RuntimeException("Error getting camera characteristics: ${e.message}")
        }
    }
 
    private fun checkCameraPermissions() {
        if (ContextCompat.checkSelfPermission(
                this,
                Manifest.permission.CAMERA
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            ActivityCompat.requestPermissions(
                this,
                arrayOf(Manifest.permission.CAMERA),
                cameraPermissionCode
            )
        }
    }
 
    private fun handleCameraViewClick(event: MotionEvent, textureView: TextureView) {
        if (event.action == MotionEvent.ACTION_UP) {
            if (textureView == textureViewFront) {
                frontCameraFullScreen = !frontCameraFullScreen
                toggleFullScreenMode(textureViewFront)
            } else if (textureView == textureViewBack) {
                backCameraFullScreen = !backCameraFullScreen
                toggleFullScreenMode(textureViewBack)
            }
        }
    }
 
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == cameraPermissionCode) {
            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // Permission granted, proceed with camera initialization
                // For simplicity, you can recreate the activity to initialize cameras
                recreate()
            } else {
                // Permission denied, handle accordingly
                Log.e("PermissionError", "Camera permission denied.")
            }
        }
    }
}
 
 
activity_main.xml:
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity">
 
    <TextureView
        android:id="@+id/textureViewFront"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        />
 
    <TextureView
        android:id="@+id/textureViewBack"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />
 
</LinearLayout>
 
 
build gradle(app):
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}
 
android {
    namespace = "com.example.multicam"
    compileSdk = 34
 
    defaultConfig {
        applicationId = "com.example.multicam"
        minSdk = 33
        targetSdk = 33
        versionCode = 1
        versionName = "1.0"
 
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }
 
    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
}
 
dependencies {
 
    implementation("androidx.core:core-ktx:1.9.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("com.google.android.material:material:1.11.0")
    implementation("androidx.constraintlayout:constraintlayout:2.1.4")
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
}
 
build gradle(project):
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.android.application") version "8.1.3" apply false
    id("org.jetbrains.kotlin.android") version "1.9.0" apply false
}
 
manifest:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
 
    <uses-permission android:name="android.permission.CAMERA" />
<uses-permission android:name="android.permission.INTERNET" />
 
    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Multicam"
        tools:targetApi="31">
<activity
            android:name=".MainActivity"
            android:exported="true">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
 
                <category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
</application>
 
</manifest>
